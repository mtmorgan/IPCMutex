% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ipccounter.R
\docType{class}
\name{cid}
\alias{cid}
\alias{counter}
\alias{yield}
\alias{value}
\alias{reset}
\alias{close.Counter}
\alias{ipcremove}
\alias{Counter-class}
\alias{.Counter}
\alias{show,Counter-method}
\title{Inter-process counter}
\usage{
cid(id)

counter(id)

yield(counter)

value(counter)

reset(counter, n)

\method{close}{Counter}(con)

ipcremove(id)

\S4method{show}{Counter}(object)
}
\arguments{
\item{id}{character(1) identifying the counter. By default,
counters with the same \code{id}, including counters in
different processes, share the same state.}

\item{counter}{instance of class \code{Count}.}

\item{n}{integer(1) value from which \code{yield(counter)} will
increment.}

\item{con}{A \code{Counter-class} instance that has not yet been
closed.}

\item{object}{An instance of class \code{Counter}.}
}
\value{
\code{cid()} returns a character(1) identifier mangled to
    include the system process identifier, providing a convenient
    way of making an approximately unique or process-local counter.

\code{counter()} returns a \code{Counter-class} instance.

\code{counter()} returns an integer(1) value representing
    the next number in sequence. The first value returned is 1.

\code{value()} returns the value to be returned by the next
    call to \code{yield()}, without incrementing the counter. If
    the counter is not longer available, \code{yield()} returns
    \code{NA}.

\code{reset()} returns \code{n}, invisibly.

\code{close()} returns \code{Counter-class} instance that
    can no longer count. Creating a new counter with the same
    \code{id} continues counting.

\code{ipcremove()} returns (invisibly) \code{TRUE} if
    external resources were release or \code{FALSE} if not (e.g.,
    because the resources has already been released). Use
    \code{ipcremove()} to remove external state associated with
    \code{id}.
}
\description{
Inter-process counter
}
\examples{
cid("egcounter")

(ipcremove(cid("egcounter")))
cnt <- counter(cid("egcounter"))
on.exit(ipcremove(cid("egcounter")))

yield(cnt)
yield(cnt)
yield(counter(cid("egcounter")))

value(cnt)

reset(cnt, 1)
value(cnt)
yield(cnt)

close(cnt)
tryCatch(yield(cnt), error = conditionMessage)
yield(counter(cid("egcounter")))

}

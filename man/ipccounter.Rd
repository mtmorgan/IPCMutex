% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ipccounter.R
\docType{class}
\name{count}
\alias{count}
\alias{yield}
\alias{value}
\alias{reset}
\alias{close.Counter}
\alias{Counter-class}
\alias{.Counter}
\alias{show,Counter-method}
\title{Inter-process counter}
\usage{
count(id, master = FALSE)

yield(counter)

value(counter)

reset(counter, n)

\method{close}{Counter}(con)

\S4method{show}{Counter}(object)
}
\arguments{
\item{id}{character(1) identifying the lock to be obtained.}

\item{counter}{instance of class \code{Count}.}

\item{n}{integer(1) value from which \code{yield(counter)} will
increment.}

\item{con}{A \code{Counter-class} instance that has not yet been
closed.}

\item{object}{An instance of class \code{Mutex}.}
}
\value{
\code{counter()} returns a \code{Counter-class} instance.

\code{counter()} returns an integer(1) value representing
    the next number in sequence. The first value returned is 1.

\code{value()} returns the value to be returned by the next
    call to \code{yield()}, without incrementing the counter.

\code{reset()} returns \code{n}, invisibly.

\code{close()} returns \code{Counter-class} instance that
    can no longer count.
}
\description{
Inter-process counter
}
\examples{
cnt <- counter()
cnt
yield(cnt)
yield(cnt)
close(cnt)

## reference semantics
cntx <- cnty <- counter()
yield(cntx)
yield(cnty)
close(cntx)         # only once

cntx <- counter()
yield(cntx)
yield(counter())    # same counter
close(cntx)

## finalizer triggered on garbage collection
yield(counter())
gc(); gc()
yield(counter())

## named counters
cnt1 <- counter("counter 1")
cnt2 <- counter("counter 2")
yield(cnt1); yield(cnt1)
yield(cnt2)
close(cnt1); close(cnt2)

}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ipccounter.R, R/ipcmutex.R
\docType{class}
\name{Counter-class}
\alias{Counter-class}
\alias{.Counter}
\alias{counter}
\alias{yield}
\alias{value}
\alias{reset}
\alias{close.Counter}
\alias{show,Counter-method}
\alias{lock}
\title{Inter-process counter}
\usage{
counter(id)

yield(counter)

value(counter)

reset(counter, n = 1)

\method{close}{Counter}(con, ...)

\S4method{show}{Counter}(object)

lock(mutex)
}
\arguments{
\item{counter}{instance of class \code{Count}.}

\item{n}{integer(1) value from which \code{yield(counter)} will
increment.}

\item{con}{A \code{Counter-class} instance that has not yet been
closed.}

\item{...}{Ignored.}

\item{object}{An instance of class \code{Counter}.}

\item{mutex}{An instance of class \code{Mutex}.}
}
\value{
\code{counter()} returns a \code{Counter-class} instance.

\code{counter()} returns an integer(1) value representing
    the next number in sequence. The first value returned is 1.

\code{value()} returns the value to be returned by the next
    call to \code{yield()}, without incrementing the counter. If
    the counter is not longer available, \code{yield()} returns
    \code{NA}.

\code{reset()} returns \code{n}, invisibly.

\code{close()} returns \code{Counter-class} instance that
    can no longer count. Creating a new counter with the same
    \code{id} continues counting.

\code{lock()} returns a \code{Mutex-class} instance.
}
\description{
Inter-process counter
}
\examples{
id <- ipcid("cnt-example")
cnt <- counter(id)

yield(cnt)
yield(cnt)
yield(counter(id))

value(cnt)
yield(cnt)

reset(cnt, 1)
value(cnt)
yield(cnt)

close(cnt)
tryCatch(yield(cnt), error = conditionMessage)
yield(counter(id))

ipcremove(id)

}
